<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>results</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="_05_results_files/libs/clipboard/clipboard.min.js"></script>
<script src="_05_results_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="_05_results_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="_05_results_files/libs/quarto-html/popper.min.js"></script>
<script src="_05_results_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="_05_results_files/libs/quarto-html/anchor.min.js"></script>
<link href="_05_results_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="_05_results_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="_05_results_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="_05_results_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="_05_results_files/libs/bootstrap/bootstrap-81267100e462c21b3d6c0d5bf76a3417.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="results" class="level1">
<h1>Results</h1>
<section id="overunder-run-scoring-analysis" class="level2">
<h2 class="anchored" data-anchor-id="overunder-run-scoring-analysis">Over/Under Run Scoring Analysis</h2>
<p>Our initial analysis focused on identifying which variables were most predictive of how many runs a team scores in a given game. We used a wide range of features grouped into three main categories:</p>
<p>Opposing starting pitcher (sp.) statistics, including metrics such as earned run average (ERA), opponent batting average (BA), innings pitched (IP), and expected stats like xERA and xBA.</p>
<p>Opposing relief pitcher statistics (rp.), which represent aggregated bullpen performance using the same types of measures as for starters, such as ERA and slugging percentage (SLG) allowed.</p>
<p>Team batter statistics (b.), covering both per-game aggregates (e.g., total hits, home runs, strikeouts) and season-long averages for the lineup, such as batting average (BA) and slugging percentage (SLG).</p>
<p>By integrating data from opposing starting pitchers, opposing relievers, and the team’s offensive performance, we aimed to construct a well-rounded model for predicting team run performance.</p>
<section id="exploratory-data-analysis" class="level3">
<h3 class="anchored" data-anchor-id="exploratory-data-analysis">Exploratory Data Analysis</h3>
<p>To gain insight into team scoring behavior, we computed summary statistics for runs scored per game. This helped us examine the distribution of offensive output and understand typical scoring ranges across all team-game observations.</p>
<figure id="fig-run_dist" class="figure">
<img src="images/run_dist.png" alt="Run Distribution" width="800" class="figure-img">
<figcaption style="font-size: 8px; color: #555;">
Figure 2: Team-level distribution of runs scored per game over the specified time period
</figcaption>
</figure>
<p>The distribution of runs scored per game, as seen in <a href="#fig-run_dist">Figure 2</a>, was right-skewed, with a few high-scoring outliers pulling the mean upward. The median was 4 runs, while the mean was slightly higher at 4.6, reflecting the impact of those outliers. This mean value serves as a useful benchmark when modeling run production in machine learning, especially when deciding how to frame our prediction target.</p>
<p>We then focused on identifying which features were most indicative of how many runs a team scores in a game. To do this, we built a linear regression model using a wide range of pitching and hitting statistics. However, many baseball metrics are inherently correlated, for example, batting average contributes heavily to a weighted on base average (wOBA). Thus, we encountered significant multicollinearity. To address this, we systematically filtered out redundant variables, prioritizing those that captured unique predictive value. After this reduction process, we finalized a simplified linear model using the following variables: <abbr title="Starting Pitcher's Earned Run Average – the average number of earned runs a starting pitcher allows per nine innings pitched." style="color: #1f77b4;">sp_era</abbr>, <abbr title="Starting Pitcher's Batting Average Against – the average number of hits allowed per at-bat by the starting pitcher." style="color: #1f77b4;">sp_ba</abbr>, <abbr title="Starting Pitcher's Slugging Percentage Against – the average total bases allowed per at-bat by the starting pitcher." style="color: #1f77b4;">sp_slg</abbr>, <abbr title="Relief Pitcher's Earned Run Average – the average number of earned runs a relief pitcher allows per nine innings pitched." style="color: #1f77b4;">rp_era</abbr>, <abbr title="Relief Pitcher's Slugging Percentage Against – the average total bases allowed per at-bat by the relief pitcher." style="color: #1f77b4;">rp_slg</abbr>, <abbr title="Relief Pitcher's Innings Pitched – the total number of innings completed by a relief pitcher for a specified game." style="color: #1f77b4;">rp_ip</abbr>, <abbr title="The mean batting average of all batters expected to appear in the lineup for a given game." style="color: #1f77b4;">b_ba</abbr>, <abbr title="Total number of strikeouts by the team's batters in the specified game." style="color: #1f77b4;">b_sum_so</abbr>, and <abbr title="The mean slugging percentage of all batters expected to appear in the lineup for a given game, measures power-hitting ability." style="color: #1f77b4;">b_slg</abbr>.</p>
<p>From our linear model, we identified three statistically significant predictors of runs scored:</p>
<ul>
<li><p>Relief pitcher ERA (rp_era), with a p-value of 0.047</p></li>
<li><p>Relief pitcher innings pitched (rp_ip), with a p-value of 0.001</p></li>
<li><p>Team batting average (b_ba), with a p-value of 0.011.</p></li>
</ul>
<p>Batting average stood out as something worth exploring further, especially as the season progresses, since we also have data on expected batting average (xBA) available.</p>
</section>
<section id="actual-vs.-expected-batting-average" class="level3">
<h3 class="anchored" data-anchor-id="actual-vs.-expected-batting-average">Actual vs.&nbsp;Expected Batting Average</h3>
<p>The law of averages suggest that after a large number of trials, outcomes tend to converge toward their expected value. While not a guarantee, this principle would imply that a teams collective batting average should align more closely with their expected batting average as the season progresses.</p>
<p>Expected batting average is a Statcast metric designed to estimate the likelihood that a batted ball will result in a hit. It is based on two key factors: exit velocity (how hard the ball is hit) and the launch angle (the angle at which the ball hits off the bat). Baseball is an incredibly difficult sport, and surface-level stats don’t always tell the full story. That is where expected statistics come in– they often provide a more accurate picture of a player’s performance. For example, a hitter might crush a ball at 115 MPH, but if it’s hit directly at a defender, it results in an out. On the other hand, a softly hit ball at just 40 MPH could drop into the perfect spot for a hit. xBA accounts for these inconsistencies by using historical data to estimate how often similar batted balls have gone for hits. While not perfect, it offers a more context-aware view of hitting performance.</p>
<figure id="fig-ba" class="figure">
<img src="images/ba.png" alt="Batting Average" width="800" class="figure-img">
<figcaption style="font-size: 8px; color: #555;">
Figure 3: Visualizing whether teams underperforming and overperforming their respective expected batting average metric.
</figcaption>
</figure>
<p>Since we are trying to understand team run production it makes sense to inspect batting average– a statistic that closely correlates with runs scored. When a team’s actual batting average is lower than its expected batting average (xBA), it is indicative of underperformance. Further, we might anticipate that, over time, they will regress upward as outcomes begin to “even out.” In other words, we would expect more batted balls to start falling for hits, raising both their batting average and, ultimately, their run totals.</p>
<p>Conversely, teams currently overperforming their xBA may regress downward, with fewer hits falling in, resulting in fewer runs scored.</p>
<p>Tracking these differences (<a href="#fig-ba">Figure 3</a>) provides valuable insight into which teams may be poised for a shift in offensive production based on their underlying quality of contact.</p>
<figure id="fig-run_diff" class="figure">
<img src="images/run_diff.png" alt="Run Differences" width="800" class="figure-img">
<figcaption style="font-size: 8px; color: #555;">
Figure 4: Identifing the teams with the largest increases and decreases in average runs scored following the All-Star Break.
</figcaption>
</figure>
<p>A pattern emerges when comparing team-level batting average (BA) versus expected batting average (xBA) with changes in run production post-All-Star Break. Teams that had been underperforming their xBA, such as CLE, CWS, KC, and HOU are now scoring significantly more runs (<a href="#fig-run_diff">Figure 4</a>), suggesting positive regression. Conversely, overperforming teams like BOS and SEA have seen their run production drop, hinting at regression to the mean. Some teams that showed a noticeable change in scoring also had differences between actual and expected batting averages, though those differences were relatively small. (<a href="#fig-ba2">Figure 5</a>).</p>
<p>The Rockies appear to be overperforming their expected batting average (xBA), but this is likely a product of Coors Field– MLB’s most hitter-friendly park. The high altitude and thin air in Denver inflate offensive stats by reducing air resistance and allowing balls to travel farther. This “Coors Field Effect” regularly skews batting metrics, making Colorado’s apparent overperformance more a reflection of park conditions than unsustainable hitting.</p>
<figure id="fig-ba2" class="figure">
<img src="images/ba2.png" alt="Batting Average Overlayed" width="800" class="figure-img">
<figcaption style="font-size: 8px; color: #555;">
Figure 5: Linking changes in run production to batting average overperformance and underperformance by teams with the largest differences post All-Star Break.
</figcaption>
</figure>
</section>
</section>
<section id="machine-learning-for-overunders" class="level2">
<h2 class="anchored" data-anchor-id="machine-learning-for-overunders">Machine Learning for Over/Unders</h2>
<p>To model over/under outcomes in MLB games, we framed the problem as a binary classification task, predicting whether a team would score over or under 4.5 runs. The 4.5 threshold reflects the historical team average of 4.6 runs, providing a meaningful baseline for classification.</p>
<p>For the classification model, we selected a Random Forest algorithm. While previous research has shown both Random Forest and XGBoost to be effective for binary classification tasks, in our case, the Random Forest model outperformed XGBoost by over 0.1 in Kappa score. Additionally, Random Forests are generally easier to interpret, especially when examining feature importance, making them a more transparent choice for communicating our models insights.</p>
<section id="feature-engineering" class="level3">
<h3 class="anchored" data-anchor-id="feature-engineering">Feature Engineering</h3>
<p>We engineered two key features: <span style="color: #1f77b4;">rolling_runs_5</span> and <span style="color: #1f77b4;">team_rolling_ba_5</span>. The <span style="color: #1f77b4;">rolling_runs_5</span> feature captures the average number of runs a team has scored over its last five games, while <span style="color: #1f77b4;">steam_rolling_ba_5</span> reflects the team’s batting average across the same span. These features provide recent performance context and turned out to be strong predictors in determining whether a team would score over or under 4.5 runs, as illustrated in (<a href="#fig-var">Figure 6</a>).</p>
<p>Additionally, we also incorporated several existing metrics into our model, including <abbr title="Opponent Starting Pitcher's Expected Batting Average – the projected batting average against a starting pitcher based on quality of contact metrics." style="color: #1f77b4;">sp_x_ba</abbr>, <abbr title="Opponent Starting Pitcher's Earned Run Average – the average number of earned runs a starting pitcher allows per nine innings pitched." style="color: #1f77b4;">sp_era</abbr>, <abbr title="Average Expected Batting Average (xBA) of the starting lineup – the projected batting average based on quality of contact and strikeouts." style="color: #1f77b4;">b_x_ba</abbr>, and <abbr title="Batting Slugging Percentage – total bases divided by at-bats, measuring a hitter's power." style="color: #1f77b4;">b_slg</abbr>.</p>
</section>
<section id="model-performance" class="level3">
<h3 class="anchored" data-anchor-id="model-performance">Model Performance</h3>
<p>To evaluate the effectiveness of our Random Forest classifier in predicting whether a team would score over or under 4.5 runs, we examined several performance metrics that offer complementary insights into model quality and reliability.</p>
<p>The Area Under the Receiver Operating Characteristic Curve (AUC) was 0.756, reflecting strong discriminative performance. This indicates that, when comparing a randomly selected game in which a team scored over 4.5 runs to one in which it did not, the model assigns a higher probability to the over outcome approximately 76% of the time. Our targeted result can be influenced by a wide range of dynamic and interrelated variables, thus an AUC above 0.75 indicates the model is reliably distinguishing between high- and low-scoring outcomes. This result suggests that the model is effectively capturing underlying patterns that differentiate high-scoring from low-scoring team performances. This performance is further illustrated by the ROC curve in <a href="#fig-roc">Figure 6</a>, which visualizes the model’s trade-off between sensitivity and specificity across all classification thresholds. The steep initial rise and bowed shape of the curve indicate effective separation between the two classes—teams that scored over 4.5 runs and those that did not—culminating in an AUC of 0.756. This reinforces the model’s reliability in identifying scoring patterns relevant to over/under predictions.</p>
<figure id="fig-roc" class="figure">
<img src="images/roc.png" alt="ROC Graph" width="800" class="figure-img">
<figcaption style="font-size: 8px; color: #555;">
Figure 6: ROC curve for the Random Forest model predicting whether a team scores over 4.5 runs. The curve illustrates the trade-off between sensitivity (true positive rate) and specificity (true negative rate). The model shows strong performance, with the curve rising well above the diagonal line
</figcaption>
</figure>
<p>In addition to AUC, overall accuracy provides a more intuitive sense of model correctness. The model achieved an overall accuracy of 72.5%, correctly predicting the outcome in nearly three-quarters of all games. This far exceeds the No Information Rate of 55.8%, which reflects the accuracy one would achieve by always predicting the majority class (in this case teams scoring under 4.5 runs). The lift over this baseline confirms that the model provides predictive value rather than simply echoing the most common outcome.</p>
<p>We also evaluated sensitivity, which measures how well the model identifies games where a team scored over 4.5 runs. It achieved a rate of 76.6%, meaning that when a team did go over, the model predicted it correctly more than three-quarters of the time. This level of performance is especially useful in betting contexts, where one would need to predict the over correctly more than 52.4% of the time just to break even. The model’s specificity was 67.2%, indicating that it also performed well at identifying games that went under.</p>
<p>Finally, we considered Cohen’s Kappa, which was 0.44. Unlike raw accuracy, Kappa adjusts for the possibility of correct predictions occurring by chance, offering a more rigorous measure of model agreement. A value of 0.44 indicates moderate agreement beyond chance, reinforcing that the model captures real predictive signals. While not exceptionally high, this level of Kappa still demonstrates that the model performs meaningfully better than random guessing—an important outcome given the inherent variability when predicting team run totals.</p>
<p>Together, these results show that our Random Forest model performs well across both interpretability and predictive accuracy dimensions, making it a valuable tool for forecasting team run production in MLB games.</p>
</section>
<section id="feature-importance" class="level3">
<h3 class="anchored" data-anchor-id="feature-importance">Feature Importance</h3>
<figure id="fig-var" class="figure">
<img src="images/var.png" alt="Important Variables for O/U ML" width="800" class="figure-img">
<figcaption style="font-size: 8px; color: #555;">
Figure 7: This figure illustrates the relative importance of each feature in predicting whether a team will score over 4.5 runs. Higher values indicate greater contribution to the model’s predictive accuracy.
</figcaption>
</figure>
<p>The variable importance plot highlights the relative contribution of each feature to the model’s predictive accuracy. Among all inputs, the engineered feature <span style="color: #1f77b4;">rolling_runs_5</span> overwhelmingly emerged as the most influential. This feature, which captures a team’s recent scoring momentum, proved to be the strongest indicator of whether a team would surpass the 4.5-run threshold. Its high importance reinforces the value of short-term performance trends in forecasting offensive output.</p>
<p>Following this, <span style="color: #1f77b4;">team_rolling_ba_5</span>—which represents the team’s batting average over the last five games—also ranked highly. This measure captures the overall quality of a team’s hitting during recent matchups, serving as a gauge of a team’s ability to consistently get hits.</p>
<p>Traditional pitching and matchup-based metrics also contributed meaningfully. For instance, <span style="color: #1f77b4;">sp_x_ba</span> and <span style="color: #1f77b4;">sp_era</span>, which reflect the expected batting average and earned run average of the opposing starting pitcher, respectively, helped capture the quality of pitching faced by the offense. These features provide critical context for how difficult it might be for a team to score in a given game.</p>
<p>Similarly, <span style="color: #1f77b4;">b_x_ba</span> (expected batting average of the lineup) and <span style="color: #1f77b4;">b_slg</span> (slugging percentage) contributed additional insight into the underlying hitting power and contact quality of the offensive side.</p>
<p>Overall, the combination of short-term offensive momentum, recent team batting metrics, and opposing pitcher quality formed the backbone of the model’s predictive framework. These findings suggest that blending engineered features with traditional matchup statistics enhances the model’s ability to predict over/under outcomes accurately.</p>
</section>
</section>
<section id="prop-betting-analysis-for-batters" class="level2">
<h2 class="anchored" data-anchor-id="prop-betting-analysis-for-batters">Prop Betting Analysis for Batters</h2>
<p>We then explored hitter-focused prop bets, specifically whether a batter would record at least one hit or exceed two total bases in a given game. Total bases are calculated as follows: a single counts as one, a double as two, a triple as three, and a home run as four. To surpass two total bases, a player could hit a double, triple, home run, or combine multiple hits (e.g., two singles). Any combination totaling more than two qualifies for the over.</p>
<section id="pitcher-batter-preview" class="level3">
<h3 class="anchored" data-anchor-id="pitcher-batter-preview">Pitcher-Batter Preview</h3>
<p>To gain an edge in predicting favorable prop outcomes, we began by analyzing game preview data for each day, including scheduled starting pitchers and historical batter-vs-pitcher matchup statistics.</p>
<p>The first areas we explored was how specific batters had performed against certain pitchers in the past. In baseball, it is often said that some hitters “have have a pitcher’s number,” meaning they see a pitcher very well— a phenomenon that may not always be captured by traditional stats. When a batter consistently succeeds against a particular pitcher, it can signal a meaningful matchup advantage. With that in mind, we prioritized these historical trends as a way to identify potentially favorable prop bet opportunities.</p>
<p>Next, we analyzed discrepancies in run value per 100 pitches (RV/100) to identify potential mismatches between pitchers and hitters. Specifically, we calculated the difference in RV/100 by comparing a batter’s performance against specific pitch types to the different pitches thrown by the scheduled opposing pitcher. This allowed us to estimate how well a batter might match up based on the types of pitches they were likely to face in a given game. In other words, we cross-referenced each batter’s strengths with a pitcher’s weaknesses to uncover matchups where a hitter may be especially well-suited to succeed. To ensure the matchup was meaningful, we also applied a minimum usage threshold, filtering out pitch types that a pitcher rarely throws.</p>
<section id="interactive-hitter-matchup-app" class="level4">
<h4 class="anchored" data-anchor-id="interactive-hitter-matchup-app">Interactive Hitter Matchup App</h4>
<p>This dashboard is built to showcase the most advantageous matchups for the games daily.</p>
<p>The top table displays advantageous batter-pitcher matchup histories, filtered to highlight hitters with the strongest track records. To ensure meaningful results, we included only hitters with a batting average above .250 against the opposing pitcher—indicating they’ve recorded a hit in more than 25% of their past at-bats. Additionally, we required a minimum of four at-bats in the matchup to ensure a more substantial sample size.</p>
<p>The table below highlights batters with a significant advantage based on run value against specific pitch types. It is sorted from highest to lowest run value difference, showcasing hitters who are most likely to succeed against the opposing pitcher’s arsenal. To qualify for this table, a batter must have a run value differential greater than 2 in their favor. If a batter appears in both this table and the matchup history table above, they are highlighted in yellow– indicating that both analyses suggest a strong likelihood of success in that day’s game.</p>
<p>Users can sort the dashboard by date, with the default view automatically displaying matchups from the current day’s slate of games. If a previous date is selected, historical matchups and their corresponding results will appear. A color-coded key is provided below the date selector to help interpret the meaning of each highlighted row.</p>
<p>At the bottom of the dashboard is a simulated betting analysis. For players to get a hit,it is typically priced around -200 odds, meaning a $200 wager would win $100. For the purpose of our analysis, we will be assuming a $10 wager per player. A successful bet yields a $5 profit, while a loss forfeits the $10 stake. For total bases (2+), where odds are usually closer to +100, we again simulate $10 wagers. In this case, a win returns $10 in profit, while a loss results in a $10 loss. The dashboard aggregates daily results based on these assumptions and displays the cumulative outcomes for easy tracking.</p>
<div style="text-align: center;">
<iframe src="https://60bwvg-jace-higa.shinyapps.io/mlb_betting/" width="100%" height="800px" style="border:none;"></iframe>
<p style="margin-top: 8px; font-style: italic; font-size: 0.95em; color: #555;">
Figure 8: Interactive dashboard showing advantageous MLB batter props, with hypothetical results displayed as well.
</p>
</div>
</section>
</section>
</section>
<section id="machine-learning-for-individual-player-props" class="level2">
<h2 class="anchored" data-anchor-id="machine-learning-for-individual-player-props">Machine Learning for Individual Player Props</h2>
<p>While the interactive dashboard approach provided valuable insights into daily matchup advantages, we recognized the need for a scalable, data-driven approach to individual player prop prediction. To complement the human-guided analysis, we developed a comprehensive machine learning pipeline focused on predicting specific prop betting outcomes using historical player performance and advanced statistical modeling.</p>
<section id="statistical-thinking-and-model-development" class="level3">
<h3 class="anchored" data-anchor-id="statistical-thinking-and-model-development">Statistical Thinking and Model Development</h3>
<p>Our machine learning approach was grounded in established sports betting research, particularly the findings of Walsh &amp; Joshi (2024) demonstrating that model calibration matters more than raw accuracy for betting profitability. Rather than optimizing solely for traditional machine learning metrics, we prioritized probability calibration to ensure our predictions would translate effectively to real-world betting scenarios.</p>
<p>We framed individual player prop prediction as a series of binary classification problems, creating target variables that directly corresponded to common betting markets: whether a player would record more than 0.5 hits (<code>hits_over_0.5</code>), more than 1.5 hits (<code>hits_over_1.5</code>), and more than 1.5 total bases (<code>total_bases_over_1.5</code>). This approach aligned our statistical models with practical betting applications while maintaining methodological rigor.</p>
<p>A central emphasis throughout our model development was avoiding data leakage to ensure our predictions would replicate information realistically available before game time. This methodological focus guided our feature engineering process and model validation approach, prioritizing realistic predictive capability over artificially inflated performance metrics.</p>
</section>
<section id="feature-engineering-and-data-leakage-prevention" class="level3">
<h3 class="anchored" data-anchor-id="feature-engineering-and-data-leakage-prevention">Feature Engineering and Data Leakage Prevention</h3>
<p>Our feature engineering process was designed with strict adherence to temporal constraints that would apply in real-world betting scenarios. We exclusively used information that would be available before game time, avoiding any same-game statistics that could artificially inflate model performance.</p>
<p>From seasonal batting statistics, we incorporated established player ability metrics including <code>season_batting_avg</code>, <code>season_obp</code>, <code>season_slg</code>, <code>season_ops</code>, <code>season_woba</code>, and <code>season_wrc_plus</code>. These provide baseline context for each player’s demonstrated skill level over the current season.</p>
<p>To capture per-game expectations without using same-game data, we calculated historical rate features such as <code>historical_hr_per_game</code>, <code>historical_hit_per_game</code>, <code>historical_walk_rate</code>, and <code>historical_k_rate</code> by dividing season totals by games played. These features provide realistic estimates of typical player output while maintaining temporal validity.</p>
<p>Experience and volume indicators included <code>games_played</code>, <code>season_games</code>, and contextual factors such as <code>is_home</code> and <code>season</code> indicators. These features capture player experience, health, and situational factors without incorporating any information from the game being predicted.</p>
<p>The final dataset comprised 19,587 player-game records across training (12,000), validation (4,000), and test (3,587) sets, with 47% of records containing complete seasonal statistical context. This represented a deliberate trade-off between data completeness and prediction reliability, focusing on players with sufficient historical information for meaningful modeling.</p>
</section>
<section id="model-architecture-and-algorithm-selection" class="level3">
<h3 class="anchored" data-anchor-id="model-architecture-and-algorithm-selection">Model Architecture and Algorithm Selection</h3>
<p>Based on academic literature review, we implemented a comparative analysis of multiple machine learning algorithms known to perform well in sports prediction contexts. Our model suite included Random Forest, XGBoost, and ensemble methods, each calibrated using isotonic regression to optimize probability estimates for betting applications.</p>
<p>The Random Forest implementation used 100 estimators with a maximum depth of 6, configured conservatively to prevent overfitting in the challenging sports prediction environment. Our XGBoost configuration employed 100 estimators with a learning rate of 0.05 and regularization parameters designed specifically for sports betting applications.</p>
<p>Most critically, following Walsh &amp; Joshi’s research demonstrating that calibration-optimized models achieved +34.69% ROI versus -35.17% for accuracy-focused models, we applied CalibratedClassifierCV with isotonic regression to all base models. This ensured our probability outputs would be well-calibrated for betting decision-making rather than optimized solely for classification accuracy.</p>
<p>To leverage the strengths of multiple algorithms, we created ensemble models using weighted voting that combined the calibrated outputs of our individual models. This approach aligned with Galekwa et al.&nbsp;(2024) findings that ensemble methods consistently outperform single models in sports betting applications.</p>
</section>
<section id="model-performance-and-validation" class="level3">
<h3 class="anchored" data-anchor-id="model-performance-and-validation">Model Performance and Validation</h3>
<p>Our comprehensive evaluation employed temporal validation with strict separation between training, validation, and test periods to simulate realistic prediction scenarios. Training data covered April-May 2025, validation used June 2025, and testing employed July 2025 data, ensuring models never saw future information during training.</p>
<p>The Random Forest model achieved the strongest performance with an average test AUC of 0.549 across target variables, followed by ensemble methods at 0.548 AUC and XGBoost at 0.548 AUC. Individual target performance varied, with <code>hits_over_1.5</code> achieving the highest AUC of 0.554, while <code>total_bases_over_1.5</code> recorded 0.543 AUC.</p>
<figure id="fig-model_performance" class="figure">
<img src="images/model_performance_comparison_final.png" alt="Model Performance Comparison" width="800" class="figure-img">
<figcaption style="font-size: 8px; color: #555;">
Figure 9: Model performance comparison across MLB player prop targets. Left panel shows all algorithms clustering near the academic baseline (Elfrink 2018), demonstrating realistic performance expectations for sports betting applications. Right panel validates absence of overfitting through strong validation-test agreement along the diagonal.
</figcaption>
</figure>
<p>When benchmarked against established academic literature, our results align closely with the documented baseline of 0.552 AUC (Elfrink, 2018) for MLB prediction tasks. This performance falls within the expected range for legitimate sports betting models that avoid data leakage, demonstrating that our emphasis on methodological rigor produced realistic performance estimates rather than artificially inflated metrics.</p>
<p>The consistency of performance across different target variables and temporal periods validates our feature engineering approach and suggests that our models captured generalizable patterns in player performance rather than overfitting to specific outcomes or time periods. As shown in <a href="#fig-model_performance">Figure 9</a>, the tight clustering of all algorithms around the academic baseline, combined with the strong validation-test agreement along the diagonal, confirms both realistic performance expectations and robust generalization capabilities.</p>
</section>
<section id="feature-importance-and-model-interpretation" class="level3">
<h3 class="anchored" data-anchor-id="feature-importance-and-model-interpretation">Feature Importance and Model Interpretation</h3>
<p>Analysis of feature importance revealed that seasonal performance metrics provided the primary predictive signal, with <code>season_batting_avg</code>, <code>season_ops</code>, and <code>season_woba</code> consistently ranking among the top contributors across all models. This finding validates the importance of established player ability as captured through comprehensive seasonal statistics.</p>
<figure id="fig-feature_importance" class="figure">
<img src="images/feature_importance.png" alt="Feature Importance Analysis" width="800" class="figure-img">
<figcaption style="font-size: 8px; color: #555;">
Figure 10: Feature importance analysis aggregated across all models and targets, demonstrating the dominance of legitimate pre-game predictors. Seasonal statistics (blue) and historical rates (orange) provide the strongest predictive signal, while the complete absence of same-game features confirms successful data leakage prevention.
</figcaption>
</figure>
<p>Historical rate calculations such as <code>historical_hr_per_game</code> and <code>historical_hit_per_game</code> proved valuable for normalizing seasonal performance across different playing time contexts. Experience indicators including <code>games_played</code> provided meaningful context about player reliability and health status.</p>
<p>As demonstrated in <a href="#fig-feature_importance">Figure 10</a>, the absence of any same-game derived features from the importance rankings confirms our successful elimination of data leakage while maintaining predictive capability. The dominance of seasonal statistics and historical rates validates our interpretation that established player ability, rather than game-specific circumstances, drives the primary predictive signal in our models.</p>
<p>Contextual factors like <code>season</code> and <code>is_home</code> showed moderate importance, suggesting systematic differences in performance across these dimensions. The absence of any same-game derived features from the top importance rankings confirms our successful elimination of data leakage while maintaining predictive capability.</p>
</section>
<section id="model-calibration-and-odds-data-integration" class="level3">
<h3 class="anchored" data-anchor-id="model-calibration-and-odds-data-integration">Model Calibration and Odds Data Integration</h3>
<p>A critical aspect of our modeling approach was ensuring well-calibrated probability outputs suitable for betting applications. Our calibration analysis demonstrated that all models produced probability estimates closely aligned with observed outcome frequencies, essential for comparing model predictions with betting market prices.</p>
<p>The ROC analysis confirmed consistent discriminative ability across different target variables, with all models achieving meaningful separation between positive and negative cases despite the challenging nature of individual player prediction.</p>
</section>
<section id="planned-integration-with-betting-market-data" class="level3">
<h3 class="anchored" data-anchor-id="planned-integration-with-betting-market-data">Planned Integration with Betting Market Data</h3>
<p>To evaluate whether our statistical models can identify profitable betting opportunities, we will integrate our calibrated probability predictions with real-time odds data from multiple sportsbooks. This integration represents the critical next phase of our hybrid modeling approach, where statistical predictions meet market-based information.</p>
<p>Our odds data infrastructure captures player prop lines from major sportsbooks including DraftKings, FanDuel, BetMGM, and Caesars across the key markets we predict: hits over 0.5, hits over 1.5, and total bases over 1.5. By implementing comprehensive odds shopping across these platforms, we can identify the most favorable lines available for each predicted outcome, maximizing potential value when our model probabilities diverge significantly from market prices.</p>
<p>The integration methodology will compare our calibrated model probabilities directly with implied probabilities from betting lines, accounting for sportsbook margins to identify genuine value opportunities. For instance, if our model assigns a 0.70 probability to a player recording 1+ hits, but the best available odds imply only a 0.60 probability (after margin adjustment), this represents a potential value bet. Consistent application of this approach across hundreds of daily prop opportunities will test whether our statistical edge translates to profitable betting outcomes.</p>
</section>
<section id="integration-with-matchup-analysis" class="level3">
<h3 class="anchored" data-anchor-id="integration-with-matchup-analysis">Integration with Matchup Analysis</h3>
<p>Our machine learning approach complements the interactive matchup analysis by providing automated screening capabilities across all players and games. While the dashboard excels at identifying specific daily opportunities through pitcher-batter historical data and pitch-type analysis, the ML models can evaluate hundreds of prop opportunities simultaneously using consistent statistical criteria.</p>
<p>This integration allows ML models to identify players whose predicted performance substantially differs from betting market prices, while the dashboard provides contextual validation through matchup-specific insights. The hybrid approach leverages both algorithmic pattern recognition capabilities and nuanced situational analysis for comprehensive opportunity identification.</p>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>